<!DOCTYPE html>
<head>
  <title>Jason Pettus: DevBootcamp Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,800' rel='stylesheet' type='text/css'>
</head>

<nav>
<ul>
  <li class="menu"><h1>Jason Pettus</h1> <a href="http://jasonpettus.github.io/"><h4>$developer:intraining;</a></h4></li>  <li class="menu"><a href="http://jasonpettus.github.io/projects.html"><h4>Projects</h4></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/about.html"><h4>About</h4></a></li>
  <li class="menu purple"><a href="http://jasonpettus.github.io/blog/index.html"><h4>DevBootcamp Blog</h4></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/cclap.html"><h4>CCLaP</h4></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/contact.html"><h4>Contact</h4></a></li>
</ul>
</nav>

<header>
  <h1>DevBootcamp Tech Blog Week 4</h1>
  <h2>Methods, Modules and #map</h2>
  <h3>March 1, 2015</h3>
</header>

<article>
<p>Week 4 of DevBootcamp now finished, and I'm still standing! But ooh, this was a hard one this week; because now that we had gotten to at least a theoretical understanding of such basic concepts in Ruby as objects, variables and methods, this week was all about trying to cram as many new methods in our heads as humanly possible, and DBC did this through a memorable but hair-pullingly frustrating way, by assigning us a series of real-world problems to solve via code from scratch, but not telling us which methods out there in existence were the ones that would solve the problem, nor where to find information on these methods to even learn the answer for ourselves. It's done this way to teach us early how to be better real-world programmers -- this is how it will work in the corporate world as well, within an industry where part of your job description is to regularly promise to do things you have no idea how to do, and out there we will have no teacher to hold our hand and patiently explain things to us. It was a hugely anxiety-forming way to learn something new (but see today's new culture-blog entry for more on that), but a profound way to help ensure that the lessons stick; and our assignment for today's tech blog is to walk a non-techie through one of these methods, and the way we figure out how to use it when we're students at DevBootcamp. I've chosen the "#map" method to explain, because it seems even at this early date that it's going to be a major one to both use and understand in my coming career as a professional Ruby developer; but as always with articles for non-techies, we need to begin with a little primer just to get us from nothing to the first sentence of today's specific conversation.</p>

<p><b>Ruby Primer: Methods, Modules, and Object-Oriented Programming</b></p>

<p>Ruby is known as an "object-oriented" programming language, which is a way of programming that's become hugely popular within the last twenty years or so. (For example, the setting of Douglas Coupland's 1995 novel <i>Microserfs</i> is a startup of ex-Microsoft employees who are supposed to be one of the first companies to exclusively code in an object-oriented programming language, which instead of Ruby they called "OOP!" in those pre-Web 2.0 days.) It's of course more complicated than this, as is everything I ever talk about in this non-techie tech blog; but ultimately what's so appealing about an OO language is that it allows you to construct code more in the same way you construct an English-language sentence, versus previous languages that were more about learning a new foreign tongue, non-Roman in nature, invented by robots. What that means in a nutshell is that every diverse thing that exists in a Ruby program is its own object, and as an object it can have its own user-defined behavior, its own user-defined look, and serve its own user-designed function, which many people compare to building a complete sentence and making sure it has all the parts needed to be considered one.</p>

<p>If Ruby is like building a sentence, then, then variables would be the nouns, certain words that you make up as the programmer to stand for static pieces of data (so that, for example, "answer_right" might equal "blue and black," and "answer_wrong" would equal "white and gold"); while Ruby's methods would be the verbs, essentially a series of action statements that can be applied to a variable by the programmer whenever they want, and in whatever combination they desire. (So perhaps you might write a method called "iq_check" that compares the answerer's choice against their IQ, then another method called "smarties_dummies" that separates these results into two standalone lists; then whenever you wrote "answer_right.iq_check.smarties_dummies" in a line of code, you'd be asking the computer to first apply the IQ check on whatever values are currently assigned to the "answer_right" variable, then route the results to your separate lists of respondees.) Again, <i>much</i> more complicated than this, but an answer like the above gets you 85 percent down the road of completely understanding the difference between variables and methods, and how they relate to a typical Ruby program.</p>

<p>But this being Ruby, a.k.a. the so-called "human-friendliest computer language in history" (still under debate, but don't tell Ruby enthusiasts that), there's actually been entire pre-existing libraries of methods that have already been built and included within Ruby itself, just the several hundred common things that most programmers as a global group have found themselves doing over and over again as a result; and there's no good way of learning and using all these several hundred pre-existing methods except by the simple yet excruciating act of sitting down and memorizing them all. But the developers of Ruby have at least tried to add a few organizational helpers to the process, and one of those is by splitting up lists of similar methods into a series of self-contained "modules" within the language, making it easier to least chop out 60 or 75 percent of all possible choices whenever you're looking for a method that does one very general thing, even if you don't know yet what it needs to do very specifically. "Enumerables" is one of these modules, which basically means "a group of methods that all take a certain string of data, then transforms it into something else than what it was;" and the "#map" method is one of these enumerables, with the understanding that the pound sign there has nothing to do with the actual coding, but is simply an English-language shortcut that Ruby developers have collectively agreed to all use when having plain-language discussions about coding, to differentiate this word from a possible variable, class, array, string, integer, or a bunch of other things it could be mistaken for. (This is one of the challenges of OO programming; that if everything is an object like everything else, it can be hard sometimes to look at a single word out of context and understand just what kind of object it is, unlike a more traditional language that might, say, have all its own methods start with a special symbol like a dollar sign, but then pre-defines this list for you so that you can't add your own.)</p>

<p><b>The Quest to Understand the #map</b></p>

<p>So where to start when you want to understand what exactly the #map method does? Well, the best place to start is with the official "user's guide" to Ruby to begin with, the <a href="http://ruby-doc.org/">Ruby Docs</a> online, collectively written by the same group of global volunteers who also make changes to the ever-newest versions of Ruby. And here's what they have to say about it...</p>

<p><center><img src="rubydocsmap.png" border=1 alt="Official Ruby Docs explanation of #map" /></center></p>

<p>Which, unbelievably enough, is actually much easier to follow and understand than most of the explanations in the Ruby Docs; which leads to the main problem with the Ruby Docs as a first destination for understanding, that you're at least guaranteed to find information there about a method, but it often leaves you at no better an understanding of the subject. In this case, though, the instructions are pretty straight-forward, and breaks down in the following way...</p>

<p>Also known in Ruby by the method name "#collect," #map essentially collects up all the data in an array and then maps it back out in a certain very specific way the programmer requests. That's basically all the gobblety-gook you're seeing in the back half of the method code there, is all the little formatting that tells the computer what I just said -- the curly brackets, for example, mark the general beginning and ending of what that method does (which also could've been written out by the words "do" and "end"); while the x between the two vertical lines (known in Ruby as "pipes") basically says, "each time you look at the next piece of data in this array as you're making a single lap through it all, temporarily assign it to the variable 'x'"; and then everything after the x is known as that method's "block of code," or just "block," the specific instructions of what it should do to x before storing that new piece of data and moving onto the next item in the array list. So in the two method examples above, the first is telling the computer to add an exclamation mark to each item in the array, before outputting a new array with the results; while the second is actually defining two new variables in each iteration through the data it's doing, not just the variable's content (symbolized here as x), but also the index number of that item, known here as i. (Or in other words, since Ruby always counts from 0, not 1, the letter "a" in this example would be known as a[0], "b" is a[1], "c" is a[2] and "d" is a[3].) Then it's telling it to multiply whatever letter is representing x in that iteration with whatever number is representing i, which is why the results give us "" ("a" times 0), "b" ("b" times 1), "cc" ("c" times 2), and "ddd" ("d" times 3). And how does it know that it should go through your array one piece at a time to begin with, and to stop exactly after one runthrough has been completed? Because someone else who is passionate about Ruby took the time to already write that part of the definition of you. <i>You're welcome!</i></p>

<p>Okay, so far so good. But I suspect that there's more than meets the eye to #map, don't you? Or at least a lot more complicated things you can probably do with it, which is why it's such a sometimes intense thing to learn a new computer language, because of all the weird and complicated things you can do with it. So at this point it's always good to do a Google search on the subject; because one of the great things about the internet in the 2010s is that there's now been a series of passionate amateurs who have written well-done, plain-language tutorials to <i>every single thing that exists on the entire planet Earth</i>, and Ruby methods are no exception. So in this case, for example, you might want to go over and <a href="http://www.eriktrautman.com/posts/ruby-explained-map-select-and-other-enumerable-methods">see what Erik Trautman has to say</a> about it, or perhaps <a href="http://www.jacopretorius.net/2012/01/ruby-map-collect-and-select.html">how Jaco Pretorius might put it differently</a>; and it's there where we learn (among other things) that #map can work with a hash just as well as an array, just as long as you include two temporary variables that the #map iteration is filling each time (see <a href="t3-arrays-hashes.html">last week's entry</a> for more), and that this method can be combined with initial attributors in a new class for powerful effect.</p>

<p>And then finally, may I please passionately urge you to end your quest for knowledge at the <a href="http://stackoverflow.com/">Stack Overflow</a> website? Although you don't really need me to tell you to go there; any new developer in training will in fact find themselves almost automatically at this amazing destination even from their first week of work, because this is easily the best destination on the web for intelligent, polite and extremely useful discussions about programming problems, no matter what the language or what the problems. (It's owned by a larger company called StackExchange which is trying to make a whole career out of useful and extra-polite discussion boards on every subject imaginable.) To be warned, this is a "rabbithole" website much like Wikipedia, where you might start on your original answer but ten impossible-to-ignore links suddenly have you ten related pages away from where you originally started, and you've read your way all through your lunch hour and didn't even notice; so in this case you might start <a href="http://stackoverflow.com/questions/12084507/what-does-the-map-method-do-in-ruby">on this page</a> which simply contains a simple discussion about #map and what you can do with it; but soon you might find yourself clicking through to find out more on <a href="http://stackoverflow.com/questions/7683408/what-happens-if-an-enumerator-tries-to-consume-input/7738359#7738359">how to apply a second enumerable</a> to an existing first enumerable (easy to do with #map), and then on, and then on, and then on.</p>

<p>Once you learn the most basic of rules about how a language works, this is how you get better at speaking it -- you seek out answers and knowledge from whatever sources you can, you look things up in the immediacy of the moment you don't understand it, you put in long-term work with flashcards to remember a bigger database of options more easily, and you rely on lots of questions and back-and-forths with your fellow learners. Add together over and over, and this is how you become a professional Ruby developer; although as I can attest from this week of constant headaches and panic attacks, it's certainly not an easy process, especially when you're trying to cram it all in fast like we're doing in DevBootcamp.</p>

<p>More next Sunday, so I hope you'll have a chance to stop by again then!</p>

</article>
