<!DOCTYPE html>
<head>
  <title>Jason Pettus: DevBootcamp Technical Blog, week 1</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
</head>

<nav>
<ul>
  <li class="menu"><h1>Jason Pettus</h1><br /><h4>$developer:intraining;</h4></li>
  <li class="menu"><a href="http://jasonpettus.github.io/projects.html"><h2>Projects</h2></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/about.html"><h2>About</h2></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/blog/index.html"><h2>DevBootcamp Blog</h2></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/cclap.html"><h2>CCLaP</h2></a></li>
  <li class="menu"><a href="http://jasonpettus.github.io/contact.html"><h2>Contact</h2></a></li>
</ul>
</nav>

<header>
  <h1>DBC Tech Blog, Week 1</h1>
  <h2>Version control, Terminal, Git, and GitHub</h2>
  <h4>February 5th, 2015</h4>
</header>

<article>
    <p>
  As part of my requirements for DevBootcamp, I will be writing a weekly technical blog and a weekly personal blog throughout my studies, explaining in the former the things I learned that week, rewritten so that non-technical people should hopefully be able to follow along, and detailing my emotions in the latter as I take on this big new challenge in my life in middle age. (<a href="http://jasonpettus.github.io/blog/c1-chefs-kitchen.html">Click here</a> for this week's "culture" blog entry.) Today's technical entry covers the first week of classes, and addresses the subjects of version control, Terminal, Git, and GitHub.
    </p>
<p><b>What Is a Computer Program?</b></p>

<p>So before anything else, let's get our absolutely most basic definition out of the way -- a <i>computer program</i> (also known as a piece of software, an application, or an "app") is nothing more than a series of text documents, each of which contains specialized words and phrases known as a specific "language," with the pages containing commands that communicate back and forth with each other to execute the things you expect that program to do. Just to name one of the most simple examples we can, in the HTML language (HyperText Markup Language, the codes that make a web page work the way it does), the way you designate a piece of text to be <i>italicized</i> is through the codes &lt;i&gt; (at the beginning of the italicized passage) and &lt;/i&gt; (at the end). That's it -- that's a computer code in a nutshell, and a shared group of such codes is known as a language, and when a human is sitting and typing these text documents that all collectively communicate with each other using this language, it's said that they're "coding" or "programming."</p>

<p><b>Terminal and Command Lines</b></p>

<p>Now, programmers use programs of their own to help facilitate the work they're doing, much like how you might use Microsoft Word to type a school essay; in DevBootcamp, for example, we're using a program called Sublime to help us format our text in specialized ways, and a program called Git to help us keep all our coded pages organized and working right. The big difference, though, is that if a coder was to use all the bells and whistles of a <i>graphical user interface</i> (or GUI) to do their work -- for example, like how you might stop for a moment in Word in the middle of your writing, grab your mouse, navigate it to the menu at the top of the screen, then choose the option "Save File" -- it would take a coder forever to get through their coding, because coding primarily relies on a heavy amount of typing, and any instance where you have to remove your fingers from your keyboard is an instance where you have slowed down to non-work.</p>

<p>So instead, coders use something called the "command line," which is basically the way you communicate with your personal computer without having to use any GUI prompts at all. Every personal computer sold has a built-in way to access the command line, and each platform works a little differently; I'm on a Mac, for example, so will be directing my comments specifically towards that platform, and on a Mac there's a little program called Terminal that comes included on every Mac that ships. (Look in your Applications folder for your own copy.) Terminal lets me hop around various locations on my computer's hard drive, and to do pretty much anything I can do with the mouse and the GUI, but a lot faster -- so if I want to make a new "folder" (also known as a directory), instead of right-clicking on my desktop with my mouse and choosing "New Folder," then naming that folder when the highlighted text underneath it appears, I simply type "mkdir jasonnew" and a new folder named "jasonnew" automatically appears.</p>

<p>Terminal is not just a replacement for your on-screen graphical interface, but is actually a lot more powerful -- this is why tech experts often go straight to Terminal when trying to fix a broken computer, because it allows you to skip past the hobbled GUI parts and do powerful changes to the guts of the machine itself. (Of course, if you don't know what you're doing, you can also accidentally destroy your hard drive, necessitating a clean wipe of everything that was already on it; that's precisely why these computer companies build the hobbling details into the graphical interface, so that non-trained customers don't accidentally destroy their machines without meaning to.) But in terms of our conversation about coding, the main thing to remember is that nearly all programming takes place through such a text-based environment, and that the first thing the budding programmer needs to do in their education is start memorizing the dozens of text commands that one uses in a program like Terminal. BE WARNED, this is what programming mainly consists of -- tons and tons and tons of rote memorization, coupled with the ability to think in a logical manner like a computer does, so to be able to fly through that programming without the "lazy" cues that a GUI provides the non-trained.</p>

<p><b>Versions</b></p>

<p>Of course, it's rare that a single person builds an entire program by themselves; usually it's a whole team of people (or for something really complicated, a whole series of teams), each of them working on various bits and pieces of that program, and eventually bringing them all together into one master set of documents that represents a "working app." And each and every time one of those documents gets changed by one of these people, that means you have a new "version" of that application, although this shouldn't be confused with the public declarations of "versions" that a company might announce when releasing an update of their app; when that company proudly tells you that "version 2.0*" is now available, behind the scenes they may have already gone through 50 or 100 much tinier versions before getting there, and are only now releasing all 100 of those tiny changes all at the same time, so that it's the "second version" for you as the customer, not for them as the programmers.</p>

<p>*The naming of public versions is a <i>wholly</i> unscientific process, done more for PR purposes than for actual technical ones, and works much like how publishers designate the difference between different "printings" and different "editions;" so for example, if a software company only cleans up a few bugs for the next public release of their app, they might call it something like "v2.1" instead of "v3.0," just like how a publisher might call a book the "second edition, second printing" if cleaning up a few typos, instead of a "third edition." The announcement of a brand-new "version" of an app is designed to genereate excitement among their buying public -- it's basically saying, "We've added so many new things this time, you absolutely must buy this newest version!" -- but has little to do with how many or how few actual changes got made to that application behind the scenes.</p>

<p><b>Version Control and Git</b></p>

<p>As you can see, with so many different people doing so many different things to so many different pages, a program would be quickly sunk if there wasn't a way to keep very careful track over who's doing what, when they did it, whether what they did worked, and whether it's been updated into the master set of documents everyone else is also working on; and that's why, over the years, these programmers have also developed programs called "version control" apps, that do nothing but keep very sophisticated track of all these changes as they happen, essentially logging in new "versions" of the program each time even a single change gets made, then "pushing" that changed version out to every person who is currently working on that program from their own local computers.</p>

<p>The version control app we're using in DevBootcamp, for example, is called Git, and is a piece of "freeware" originally developed by the first team of people who also invented the open-source Linux operating system, basically as a response to earlier VC apps that didn't work quite as well. It's pretty ingenious, too -- basically, a copy of it sits on every local computer of every person working on a program, and not only does it contain the local version that they themselves are changing right that moment, but also a full copy of the master set of documents, on each and every local computer. That way, if something ever happens to the centralized "master" that everyone else is pulling from (for example, if the company hosting that master version suddenly decides that it no longer wants to do business with you, exactly what happened to the Linux team which is what convinced them to invent Git in the first place), when a new centralized master is set up, you can pull that new master off of ANY LOCAL COMPUTER that had been previously working on it, giving you not just one backup copy of any program but as many backups as there are people working on it.</p>

<p>You can think of the process of updating a program through Git as a series of logical steps that take place in a proscribed order...</p>

<p>--First, you "fetch" the latest version of the centralized set of documents that everyone else is working on too -- this is the "official" version of the app, and in Git terms is known as the "origin;"</p>

<p>--Then you make your own changes to that program on your own computer, using a text editor like Sublime (or, hey, just even SimpleText if you want -- the text editor doesn't matter, as long as it's outputting true ASCII plain text, not specialized "formatted text" like in Microsoft Word for example);</p>

<p>--Then you "add" those changed documents to what's called a "staged" version of your new origin; basically, that's a new version of the program that's <i>almost</i> ready to become official, except for taking one last look through it and making sure it's doing everything you want it to. (And in fact, most often when it's teams of people working together, a staged version of a program will actually be sent to someone else for a final looking over; asking someone to do this for you is known as making a "pull request," in that they then "pull" your local version over to their own local computer to take a look at it.)</p>

<p>--Then once you're confident that your staged version is looking fine, you then "commit" that version so that it's now your new master copy, then "push" that new master back to the centralized origin. At that point Git makes a note that a new version (or "commit" as a noun) has been made, it logs it into its master log of all commits, and it replaces the older version with your new version to become the new "origin" version that everyone else will now fetch themselves.</p>

<p>--Repeat one thousand times, and you have a working computer program!</p>

<p><b>GitHub</b></p>

<p>And finally for week one of DevBootcamp, we covered a website called GitHub, which is about the easiest thing to understand out of all of this -- it's basically Facebook for Git users, a social network where every person has their own account, every account has its own page, and every page can host "origin" copies of multiple programs (also known as a "repository" or "repo"), which then becomes the official centralized version that everyone else is working off of. Repos can be designated either as private or public; my first repo, for example, which contains the files of this blog, is public so that all of you can see it, while our class pages for DevBootcamp are private so that only paid students can see them.</p>

<p>I hope you'll be able to join me next week, when I'll be going over the ins-and-outs of HTML and CSS, the powerful one-two combination that makes web pages look and behave the way they do. Until then, as always, you can always drop me some feedback about what you read here by writing ilikejason@gmail.com, or tweeting my DevBootcamp Twitter account at <a href="http://www.twitter.com/jason_pettus">@jason_pettus</a>. See you next week!</p>

</article>


